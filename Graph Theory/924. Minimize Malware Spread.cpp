///Using DFS
class Solution {
public:
    void dfs(int node, vector<int> &vis, int &count, vector<int> al[]){
        
        vis[node] = 1;
        count++;
        
        for(int j = 0; j < al[node].size(); j++){
            int child = al[node][j];
            if(vis[child] == 0){
                dfs(child, vis, count, al);
            }
        }
    }
    int countNodes(int n, int ind, vector<int> &initial, vector<int> al[]){
        
        vector<int> vis(n, 0);
        int count = 0;
        
        for(int j = 0; j < initial.size(); j++){
            if(j == ind) continue;
            if(vis[initial[j]] == 0){
                dfs(initial[j], vis, count, al);
            }
        }
        
        return count;
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        
        int n = graph.size();
        
        vector<int> al[n];
        
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++){
                if(graph[i][j]){
                    al[i].push_back(j);
                    al[j].push_back(i);
                }
            }
        }
        
        int minNodes = INT_MAX, node = -1;
        
        for(int i = 0; i < initial.size(); i++){
            
            int temp = countNodes(n, i, initial, al);
            if(temp < minNodes){
                minNodes = temp;
                node = initial[i];
            }
            else if(temp == minNodes){
                node = min(node, initial[i]);
            }
        }
        return node;
    }
};

//Using DSU
//Ref: https://www.youtube.com/watch?v=8__sEBHzC00
class Solution {
public:
    int findp(int node, vector<int> &par){
        if(par[node] == node){
            return node;
        }
        return par[node] = findp(par[node], par);
    }
    void unionp(int node1, int node2, vector<int> &par, vector<int> &sz){
        sz[node1] += sz[node2];
        par[node2] = node1;
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        
        int n = graph.size();
        
        vector<int> par(n), sz(n, 1);
        
        for(int i = 0; i < n; i++){
            par[i] = i;
        }
        
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++){
                if(graph[i][j]){
                    int u = i, v = j;
                    int paru = findp(u, par);
                    int parv = findp(v, par);
                    if(paru != parv){
                        unionp(paru, parv, par, sz);
                    }
                }
            }
        }
        
        vector<int> infected(n, 0);
        
        for(int i = 0; i < initial.size(); i++){
            int pari = findp(initial[i], par);
            infected[pari]++;
        }
        
        sort(initial.begin(), initial.end());
        
        int maxNodes = INT_MIN, node = -1;
        
        for(int i = 0; i < initial.size(); i++){
            int pari = findp(initial[i], par);
            if(infected[pari] == 1){
                if(sz[pari] > maxNodes){
                    maxNodes = sz[pari];
                    node = initial[i];
                }
            }
        }
        
        if(node == -1){
            return initial[0];
        }
        return node;
    }
};
