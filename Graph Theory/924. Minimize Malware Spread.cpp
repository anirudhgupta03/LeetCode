///Using DFS
class Solution {
public:
    void dfs(int node, vector<int> &vis, int &count, vector<int> al[]){
        
        vis[node] = 1;
        count++;
        
        for(int j = 0; j < al[node].size(); j++){
            int child = al[node][j];
            if(vis[child] == 0){
                dfs(child, vis, count, al);
            }
        }
    }
    int countNodes(int n, int ind, vector<int> &initial, vector<int> al[]){
        
        vector<int> vis(n, 0);
        int count = 0;
        
        for(int j = 0; j < initial.size(); j++){
            if(j == ind) continue;
            if(vis[initial[j]] == 0){
                dfs(initial[j], vis, count, al);
            }
        }
        
        return count;
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        
        int n = graph.size();
        
        vector<int> al[n];
        
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++){
                if(graph[i][j]){
                    al[i].push_back(j);
                    al[j].push_back(i);
                }
            }
        }
        
        int minNodes = INT_MAX, node = -1;
        
        for(int i = 0; i < initial.size(); i++){
            
            int temp = countNodes(n, i, initial, al);
            if(temp < minNodes){
                minNodes = temp;
                node = initial[i];
            }
            else if(temp == minNodes){
                node = min(node, initial[i]);
            }
        }
        return node;
    }
};

//Using BFS
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        
        int n = graph.size();
        
        int minCount = INT_MAX, minID = INT_MAX;
        
        for(auto &x: initial){
            queue<int> q;
            for(int j = 0; j < initial.size(); j++){
                if(x == initial[j]) continue;
                q.push(initial[j]);
            }
            
            vector<int> vis(n, 0);
            
            while(!q.empty()){
                
                int curr = q.front();
                q.pop();
                
                if(vis[curr]) continue;
                vis[curr] = 1;
                
                
                for(int j = 0; j < n; j++){
                    if(graph[curr][j] && curr != j){
                        q.push(j);
                    }
                }
            }
            
            int count = 0;
            
            for(int i = 0; i < n; i++){
                if(vis[i]) count++;
            }

            if(count < minCount){
                minCount = count;
                minID = x;
            }
            else if(count == minCount){
                minID = min(minID, x);
            }
        }
        return minID;
    }
};

//Using DSU
//Ref: https://www.youtube.com/watch?v=8__sEBHzC00
class Solution {
public:
    int findp(int node, vector<int> &par){
        if(par[node] == node){
            return node;
        }
        return par[node] = findp(par[node], par);
    }
    void unionp(int node1, int node2, vector<int> &par, vector<int> &sz){
        sz[node1] += sz[node2];
        par[node2] = node1;
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        
        int n = graph.size();
        
        vector<int> par(n), sz(n, 1);
        
        for(int i = 0; i < n; i++){
            par[i] = i;
        }
        
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++){
                if(graph[i][j]){
                    int u = i, v = j;
                    int paru = findp(u, par);
                    int parv = findp(v, par);
                    if(paru != parv){
                        unionp(paru, parv, par, sz);
                    }
                }
            }
        }
        
        vector<int> infected(n, 0);
        
        for(int i = 0; i < initial.size(); i++){
            int pari = findp(initial[i], par);
            infected[pari]++;
        }
        
        sort(initial.begin(), initial.end());
        
        int maxNodes = INT_MIN, node = -1;
        
        for(int i = 0; i < initial.size(); i++){
            int pari = findp(initial[i], par);
            if(infected[pari] == 1){
                if(sz[pari] > maxNodes){
                    maxNodes = sz[pari];
                    node = initial[i];
                }
            }
        }
        
        if(node == -1){
            return initial[0];
        }
        return node;
    }
};
